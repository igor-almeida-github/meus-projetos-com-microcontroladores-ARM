/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

void fun_add(void){
	__asm volatile("LDR R0,[R1]");
	__asm volatile("LDR R1,[R2]");
	__asm volatile("ADD R1,R0");
	__asm volatile("STR R1,[R3]");

	// O mesmo pode ser feito com...
//	__asm volatile(
//			"LDR R0,[R1]\n\t"
//			"LDR R1,[R2]\n\t"
//			"ADD R1,R0\n\t"
//			"STR R1,[R3]\n\t"
//	);
}

/* Info:
 * Assembly statement:
 * __asm volatile(code : output operand list : input operand list : clobber list);
 * code                -> Assembly mnemonic defined as a string
 * output operand list -> A list of output operands, separated by commas
 * input operand list  -> A list of input operands, separated by commas
 * clobber list        -> Tell the compiler about modifications done by the assembly
 * OBS: Aplicavel somente para arm gcc compiler
 */

int main(void)
{
	//	__asm volatile("LDR R1,=#0x20001000"); // Load 0x20001000 into R1
	//	__asm volatile("LDR R2,=#0x20001004"); // Load 0x20001004 into R2
	//	__asm volatile("LDR R0,[R1]");  // Load into R0 from memory location pointed by R1
	//	__asm volatile("LDR R1,[R2]");  // Load into R1 from memory location pointed by R2
	//	__asm volatile("ADD R0,R0,R1");  // Armazena em R0(primeiro) a soma de R0(segundo) com R1(terceiro)
	//	__asm volatile("STR R0,[R2]");  // Store R0 content into memory location pointed by R2

	// ----------------------------------------------------------------------------------------------------

	//	int val = 0x50;
	//	__asm volatile ("MOV R0,%0": : "r"(val));  // Move para destino R0 o valor na fonte val // %0 se refere ao primeiro operador de entrada
	// ----------------------------------------------------------------------------------------------------

	//	uint32_t control_reg;
	//
	//	__asm volatile("MRS %0,CONTROL":"=r"(control_reg));  // Movendo de registro especial do processador

	// ----------------------------------------------------------------------------------------------------

	//	int var1=10, var2;
	//
	//	__asm ("MOV %0,%1": "=r"(var2): "r"(var1));  // Movendo de uma vari√°vel para outra

	// ----------------------------------------------------------------------------------------------------

	int p1, *p2;

	p2 = (int *)0x20000008;

	__asm volatile("LDR %0,[%1]": "=r"(p1): "r"(p2)); // p1 = *p2

	for(;;);
}















