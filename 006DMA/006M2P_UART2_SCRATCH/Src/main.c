/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"

/***************************************************************************
 *                           MACROS                                        *
 ***************************************************************************/


/***************************************************************************
 *                       GLOBAL VARIABLES                                  *
 ***************************************************************************/

char somedata[] = "Hello World\r\n";


/***************************************************************************
 *                       FUNCTIONS PROTOTYPES                              *
 ***************************************************************************/
void button_init(void);
void uart2_init(void);
void dma1_init(void);
void send_some_data(void);
void enable_dma1_stream6(void);
void dma1_interrupt_configuration(void);

void HT_Complete_callback(void);
void FT_Complete_callback(void);
void TE_Complete_callback(void);
void FE_Complete_callback(void);
void DME_Complete_callback(void);

/***************************************************************************
 *                               MAIN                                      *
 ***************************************************************************/

int main(void)
{
	/* Initializations */
	button_init();
	uart2_init();
	dma1_init();
	dma1_interrupt_configuration();

	// send_some_data();

	enable_dma1_stream6();

    /* Loop forever */
	for(;;);

}

/***************************************************************************
 *                              FUNCTIONS                                  *
 ***************************************************************************/

void button_init(void){
	/* Info: Button is connected to PA0
	 *
	 */

	// 1. Enable the clock for GPIOA
	RCC->AHB1ENR |= (1 << RCC_AHB1ENR_GPIOAEN_Pos);

	// 2. Keep GPIO pin in INPUT mode (We don't need to do anything here)

	// 3. Enable the clock for SYSCFG  (We don't need to do anything here)

	// 4. Configure the SYSCFG EXTI register (We don't need to do anything here)

	// 5. Configure the edge detection on that GPIO pin
	EXTI->RTSR |= (1 << EXTI_RTSR_TR0_Pos);

	// 6. Enable the interrupt over that GPIO pin
	EXTI->IMR |= (1 << EXTI_IMR_MR0_Pos);

	// 7. Enable the IRQ related to that GPIO pin in NVIC
	NVIC_EnableIRQ(EXTI0_IRQn);


}

void uart2_init(void){

	// 1. Enable the clock for UART2 peripheral and GPIOA
	RCC->APB1ENR |= (1 << RCC_APB1ENR_USART2EN_Pos);
	RCC->AHB1ENR |= (1 << RCC_AHB1ENR_GPIOAEN_Pos);

	// 2. Configure the GPIO pins for UART2 TX and RX ->  AF7 - (PA2-TX    PA3-RX)
	// 2.1 - Change the mode to alternate function mode
	GPIOA->MODER |= (0b10 << GPIO_MODER_MODE2_Pos) | (0b10 << GPIO_MODER_MODE3_Pos);
	GPIOA->AFR[0] |= (7 << GPIO_AFRL_AFSEL2_Pos) | (7 << GPIO_AFRL_AFSEL3_Pos);

	// 2.2 - Enable or disable PULL resistors if required
	GPIOA->PUPDR |= (0x1 << GPIO_PUPDR_PUPD2_Pos);  // Pull-up
	GPIOA->PUPDR |= (0x1 << GPIO_PUPDR_PUPD3_Pos);

	// 3. Configure the baudrate 115200
	USART2->BRR = 0x8B;

	// 4. Configure the data width, no of stop bits, etc <default is fine>

	// 5. Enable the TX engine
	USART2->CR1 |= (1 << USART_CR1_TE_Pos);

	// 6. Enable the UART2 peripheral
	USART2->CR1 |= (1 << USART_CR1_UE_Pos);


}

void dma1_init(void){

	// 1. Enable the peripheral clock for the DMA1
	RCC->AHB1ENR |= (1 << RCC_AHB1ENR_DMA1EN_Pos);

	// 2. Identify the stream and channel number suitable for USART2 (channel 4, stream 6)
	DMA1_Stream6->CR |= (4 << 25);

	// 3. Program the source address
	DMA1_Stream6->M0AR = (uint32_t)&somedata;

	// 4. Program the destination address
	DMA1_Stream6->PAR = (uint32_t)&USART2->DR;

	// 5. Program number of data items to send
	uint32_t len = sizeof(somedata);
	DMA1_Stream6->NDTR = len;

	// 6. The direction of the data transfer M2P
	DMA1_Stream6->CR |= (0b01 << 6);

	// 7. Program the source and destination data width (default 8 bits is fine) and enable memory auto increment
	DMA1_Stream6->CR |= (1 << 10);

	// 8. Direct mode or FIFO mode (FIFO mode)
	DMA1_Stream6->FCR |= (1 << 2);

	// 9. Select the FIFO threshold (FULL FIFO)
	DMA1_Stream6->FCR |= (0x3 << 0);

	// 10. Enable circular mode if required (disabled by default)

	// 11. Single transfer or burst transfer (single transfer by default)

	// 12. Configure the stream priority (low by default)

}

void enable_dma1_stream6(void){
	DMA1_Stream6->CR |= (1 << 0);
}

void dma1_interrupt_configuration(void){
	// 1. Half-transfer IE (HTIE)
	DMA1_Stream6->CR |= (1 << 3);

	// 2. Transfer complete IE (TCIE)
	DMA1_Stream6->CR |= (1 << 4);

	// 3. Transfer error IE (TEIE)
	DMA1_Stream6->CR |= (1 << 2);

	// 4. FIFO overrun/underrun IE (FEIE)
	DMA1_Stream6->FCR |= (1 << 7);

	// 5. Direct mode error IE (DMEIE)
	DMA1_Stream6->CR |= (1 << 1);

	// 6. Enable the IRQ related to DMA1 stream6 in NVIC
	NVIC_EnableIRQ(DMA1_Stream6_IRQn);

}

void send_some_data(void){
	uint32_t len = sizeof(somedata);

	for(uint32_t i=0; i<len; i++){
		while(!(USART2->SR & USART_SR_TXE_Msk));
		USART2->DR = somedata[i];
	}

}

void HT_Complete_callback(void){

}

void FT_Complete_callback(void){

}

void TE_Complete_callback(void){

}

void FE_Complete_callback(void){

}

void DME_Complete_callback(void){

}







































